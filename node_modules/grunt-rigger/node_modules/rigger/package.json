{
  "name": "rigger",
  "description": "Javascript file parser and include engine",
  "author": {
    "name": "Damon Oehlman",
    "email": "damon.oehlman@sidelab.com"
  },
  "tags": [
    "build"
  ],
  "version": "0.3.20",
  "main": "./lib/rigger.js",
  "bin": {
    "rig": "./bin/rig"
  },
  "engines": {
    "node": ">= 0.6.x < 0.9.0"
  },
  "dependencies": {
    "async": "0.1.x",
    "debug": "*",
    "getit": "0.2.x",
    "squirrel": "0.1.x",
    "underscore": "1.3.x"
  },
  "pluginDependencies": {
    "coffee-script": "1.3.x",
    "stylus": "0.28.x",
    "nib": "0.7.x",
    "pegjs": "0.7.x"
  },
  "devDependencies": {
    "mocha": "1.2.x",
    "rigger-collate": "0.4.x",
    "coffee-script": "1.3.3",
    "stylus": "0.28.2",
    "nib": "0.7.0"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/buildjs/rigger.git"
  },
  "bugs": {
    "url": "http://github.com/buildjs/rigger/issues"
  },
  "scripts": {
    "test": "node_modules/mocha/bin/mocha --reporter spec --timeout 30000"
  },
  "contributors": [],
  "readme": "# Rigger\n\nRigger is a build time include engine for Javascript, CSS, CoffeeScript and in general any type of text file that you wish to might want to \"include\" other files into.\n\n<a href=\"http://travis-ci.org/#!/buildjs/rigger\"><img src=\"https://secure.travis-ci.org/buildjs/rigger.png\" alt=\"Build Status\"></a>\n\nIt was created to make the process of creating Javascript libraries a more structured process, but can be used for other tasks also. \n\nAs a developer you are encouraged to write modular, reusable code but when it comes to writing client-side applications your ability to do this effectively is generally hampered by what I call the _single-file principle_.  In most cases a good programmer rages against this and implements some kind of custom `Makefile`, [ant build](http://ant.apache.org/) or [Rakefile](http://rake.rubyforge.org/) to help with their build.\n\nThe \"build\" process, however, generally involves taking a number of files and concatenating them together in a sensible order.  I, however, wanted something more flexible.  To be precise, I wanted the following:\n\n- The ability to inject a file into specific line in another file.\n- The ability to reuse code from other libraries.\n- The ability to do includes from the web (namely github repos)\n\nThis is the functionality that Rigger provides.  It was originally built 6 months ago as part of [Interleave](/DamonOehlman/interleave) but has it's own identity, tests and is generally better.\n\n## Using Rigger\n\nFirst you will want to install it.  You'll need [npm](http://npmjs.org) to do this, once you do you can simply run `npm install -g rigger`. To get starting using rigger, you simply start placing special __include comments__ in a file that you want rigger to process.\n\n__Javascript:__\n\n```js\n//= includes/test\n```\n\n__CoffeeScript:__\n\n```coffee\n#= includes/test\n```\n\n__CSS:__\n\n```css\n/*= includes/test */\n```\n\nNotice that each of the examples is using single-line comments (even if they are a block comment in the case of the CSS example).  This is important to note as Rigger parses files on a __line by line__ basis rather through through tokenizing.  If you use block comments like the following CSS example, it won't work:\n\n```css\n/*=\nincludes/test1\nincludes/test2\n*/\n```\n\nOnce you have a file that is has been properly rigged, you can use the `rig` command line tool to turn a rigged file into it's big brother:\n\n```\nrig input.js > output.js\n```\n\n## Include All the Things\n\nRigger supports a number of special include formats, and these are demonstrated in examples below.  While JS examples are provided, the formats will work in any of the known file formats.\n\n### Remote Resources\n\nRemote resources are those stored accessible via HTTP (or HTTPS).  \n\n__HTTP(S) Include:__\n\n```js\n// include jquery from the CDN so you can run offline perhaps...\n//= http://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js\n```\n\n__Github Include:__\n\n```js\n//= github://DamonOehlman/alignit/alignit.js\n```\n\n### Multiple File Include\n\nBeing lazy is ok.  Rigger provides some nice shortcuts to help you in your quest:\n\n__Directory Includes:__\n\nSimply specify a directory in the include string and all files of the same type as the currently parsed file will be included.  In the tests/input directory have a look for the `local-includedir.js` and `local-includedir.css` files.\n\n```js\n//= ../includes/testdir\n```\n\n__Cherrypick Include:__\n\nIn some instances you may want to cherrypick particular files from a directory / remote repository.  Rather than typing multiple include lines, you can simply type one statement and use square brackets to signal to Rigger that you want to include multiple files:\n\n```js\n//= ../includes/testdir[a, b]\n```\n\n## Plugin Support\n\nIn addition to including files you can also use some plugins to extend the core functionality.  To flag that you want to use a plugin in your core files, use add the word plugin __directly__ after the `=` in the comment (e.g. `//=plugin name params`, `/*=plugin name params */`, `#=plugin name params`, etc).\n\nMore soon...\n\n## Programmatic Use\n\nTo be completed.\n\n## Streams FTW!\n\nOne of the simplest ways of composing process flows in node is to use streams, and while Interleave does not support a streaming interface, Rigger inherits from the node [Stream](http://nodejs.org/docs/latest/api/stream.html).\n\nThis means that you can do all kinds of things prior to rigging in your inline dependencies and all kinds of things afterwards to.",
  "_id": "rigger@0.3.20",
  "_from": "rigger@0.3.x"
}
