{
  "name": "getit",
  "description": "Retrieve local and remote files through a simple interface",
  "author": {
    "name": "Damon Oehlman",
    "email": "damon.oehlman@sidelab.com"
  },
  "tags": [
    "request",
    "http"
  ],
  "version": "0.2.1",
  "main": "index.js",
  "engines": {
    "node": ">= 0.4.x < 0.9.0"
  },
  "dependencies": {
    "debug": "*",
    "mkdirp": "*",
    "request": "2.x.x"
  },
  "devDependencies": {
    "mocha": "1.3.x",
    "rimraf": "2.x.x"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/DamonOehlman/getit.git"
  },
  "bugs": {
    "url": "http://github.com/DamonOehlman/getit/issues"
  },
  "scripts": {
    "test": "mocha --reporter spec --timeout 10000"
  },
  "contributors": [],
  "optionalDependencies": {},
  "readme": "# Get It\n\nThis is a simple remote file loader that makes it easy to open both local and remote files in a simple (and consistent) way.\n\n<a href=\"http://travis-ci.org/#!/DamonOehlman/getit\"><img src=\"https://secure.travis-ci.org/DamonOehlman/getit.png\" alt=\"Build Status\"></a>\n\n## Example Usage\n\nGetting a file:\n\n```js\ngetit('files/test.txt', function(err, data) {\n    \n});\n```\n\nGetting some online content:\n\n```js\ngetit('http://www.google.com/', function(err, data) {\n    \n});\n```\n\n### Specifying the Current Working Directory\n\nBy default, all files are resolved to the current working directory through using  [path.resolve](http://nodejs.org/docs/latest/api/path.html#path.resolve).  The default directory resolved against can be overriden, however, by passing options to the `getit` function call:\n\n```js\ngetit('files/test.txt', { cwd: __dirname }, function(err, data) {\n    \n});\n```\n\nSpecifying the `cwd` option has no effect on remote requests, but there might be other options added in time to tweak the [request](https://github.com/mikeal/request) behaviour eventually.  The general principle is you should be able to use `getit` to get the content of both local and remote resources without having to dramatically change the way you use the library.\n\n## Custom URL Schemes\n\nSimilar code to this has been implemented in the JS build tool [Interleave](https://github.com/DamonOehlman/interleave) and will eventually be replaced by integrating getit instead.  For this reason some helper URI schemes have been added.\n\n### Github Includes (github://)\n\n```js\ngetit('github://DamonOehlman/getit/index.js', function(err, data) {\n});\n```\n\n### Github Gists (gist://)\n\nTo get the default file (first file) from a particular gist:\n\n```js\ngetit('gist://3344823', function(err, content) {\n});\n```\n\nTo get a specific file from a particular gist:\n\n```js\ngetit('gist://3344823/gistfile1.md', function(err, content) {\n});\n```\n\n## Contributing URL Schemes\n\nI haven't as yet ported the schemes from interleave across yet, but the process is incredibly simple, and the content of the [github scheme translator](/DamonOehlman/getit/blob/master/lib/schemes/github.js) is shown below:\n\n```js\nvar url = require('url');\n\nmodule.exports = function(parts, original) {\n    var pathParts = parts.pathname.replace(/^\\//, '').split('/');\n    \n    return 'https://raw.github.com/' + parts.host + '/' + \n        pathParts[0] + '/master/' + pathParts.slice(1).join('/');\n};\n```\n\nThe task of the scheme translator is to convert a url of the custom scheme into a standard URI that can be passed to the [request](https://github.com/mikeal/request) library to GET.  \n\nTo create your own scheme translator simply fork the library, decide on the scheme / protocol prefix (e.g. github, flickr, etc) and then create the relevant translator in the `lib/schemes` directory.  When `getit` encounters a request for a url matching your custom scheme translator will be required and involved before actually requesting the url.  Simple.\n\n<a name=\"using-streams\" />\n## Using Streams\n\nIf you would like to make use node's excellent streams support, then you can do that very easily.  Simply call `getit` but don't provide a callback function.  In this mode getit will return a stream that can be piped to another stream, e.g.\n\n```js\ngetit('github://DamonOehlman/getit/test/files/test.txt').pipe(fs.createWriteStream('testfile.txt'));\n```\n\n## GetIt Options\n\nThe `getit` function supports a second argument for providing options to change the default getit behaviour.  \n\n### Caching use `cachePath`\n\nIf you provide an optional `cachePath`, then getit will cache a copy of the data retrieved in the specified path.  In addition to the data retrieved, an [etag](http://en.wikipedia.org/wiki/HTTP_ETag) value will be stored in a lookup file.  This will be used in subsequent lookups using the `If-None-Match` header.\n\nBy default, caching will only occur on a server that provides an etag value, but this can be overridden by also setting the `cacheAny` option to true.\n\n```js\nvar opts = {\n    cachePath: '/tmp'\n};\n\ngetit('github://DamonOehlman/getit/test/files/test.txt', opts, function(err, data) {\n    \n});\n```\n\nFinally, if you would prefer not to wait around for a HTTP request and a `304` response, then you can provide the `preferLocal` option always used the cached copy of a file if it exists in the cache folder.\n\n### Aggressive caching with `preferLocal`\n\nIf you __really__ want to avoid a round-trip to web servers to check the freshness of the cache, then it might be worth using the `preferLocal` option also.  This instructs getit to skip the `etag` check if it finds the required file in the cache directory.\n\nIf you do decide to implement this functionality, it's recommended that you provide some option in your application to allow users to clear the local cache path.",
  "_id": "getit@0.2.1",
  "_from": "getit@0.2.x"
}
